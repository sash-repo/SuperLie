BeginPackage["SuperLie`Cohom`",
 {"SuperLie`", "SuperLie`Domain`", "SuperLie`Enum`",
  "SuperLie`Space`", "SuperLie`Submod`", "SuperLie`Genvect`", "SuperLie`Symalg`",
  "SuperLie`Deriv`", "SuperLie`Generate`", "SuperLie`Vsplit`"}]

(*
  This package defines functions for calculation of cohomologies.

  It allows calculating cohomologies of Lie [super]algebas defined
  in Tabular mode with coefficients in any module that may be splitted
  in sum of finit-dimensional subspaces.

  If another algebra g acts on both main algebra a and on module of coefficients
  m so that a+g acts on m and d(g(f))==g(d(f)), the action of g may be used in
  calculation. It is enough to calculate highest vectors in cohomologies (with
  respect to an even semisimple subalgebra of g)
*)

SuperLie`Cohom`ch$raise::usage = "List of rising vectors in even semisimple part of g0";
SuperLie`Cohom`ch$lower::usage = "List of lowering vectors in even semisimple part of g0";
SuperLie`Cohom`ch$alg::usage = "The algebra those cohomoligies are calculated";
SuperLie`Cohom`ch$d::usage = "module DLeft[ch$alg]";
SuperLie`Cohom`ch$g0::usage = "an algebra acting on ch$alg";
SuperLie`Cohom`ch$gen::usage = "the list of generators of ch$g0";
SuperLie`Cohom`ch$basis::usage =
    "ch$basis[r,deg] should return the list of all r-forms of degree deg";
SuperLie`Cohom`ch$Split::usage = "the function used to split basis to homogenous parts"
SuperLie`Cohom`chSetAlg::usage =
  "chSetAlg[alg,dalg] defines dalg as DLeft[alg] and stores alg as algebra
  for calculanion of cohomologies. chSetAlg[alg,dalg,g0,cf] defines also the
  algebras that acts on alg and the module of coefficient. Algebras alg and
  g0 should be already defined as well as the action of g0 on alg. The cf may
  be (a) a number, for trivial coefficients, (b) a name of an alg- and g0-module,
  or (c) a basis (list of vectors) in such module";

SuperLie`Cohom`chScalars::usage =
 "chScalars[b,c] declares scalar coefficients to be used in calculations"


SuperLie`Cohom`chHVect::usage=
 "chHVect[f] caclulates the highest vectors in the space given as general sum f."
SuperLie`Cohom`chLVect::usage=
 "chLVect[f] caclulates the lowest vectors in the space given as general sum f."

SuperLie`Cohom`chGenDim::usage=
 "chGenDim[f] returns the number of indeterminate coefficients in the general sum f."

SuperLie`Cohom`chCoHom::usage=
 "chCoHom[s, r] calculates the component of grade s of the kernel and the image of operator
 \!\(d:\[CapitalOmega]\^r\[LongRightArrow]\[CapitalOmega]\^\(r+1\)\)."

SuperLie`Cohom`ch$res::usage = "The results of chCalc are stored in ch$res[s,r]={ker,im}"
SuperLie`Cohom`ch$tab::usage = "The table of dimensions are stored in ch$tab[s]"
SuperLie`Cohom`chRes::usage = "chRes[] returns the last calculated cohomology.
  chRes[s,r] prints the results of calculations of (<=r)-cohomologies of grade s."

SuperLie`Cohom`chEqu::usage=
 "chEqu[s, r, w] solves equations of exactness on coefficients of general
  closed r-form of grade s and weight w."

SuperLie`Cohom`chCalc::usage=
 "chCalc[s,r] calculates (<=r)-cohomologies of grade s and prints the results.
chCalc[s,-r] is equivalent to chCalc[s,r] but uses less memory and does not support chCalcMore"

SuperLie`Cohom`chCalcMore::usage=
 "chCalcMore[r] calculates continues calculations made with last chCalc up to
r-cohomologies and prints the results. chCalcMore[] calculates one (next)
cohomology. chCalcMore[-r] is equivalent to chCalcMore[r] but uses less memory and does not support further chCalcMore"

SuperLie`Cohom`chQuot::usage="chQuot[q,d,r] builds q=ker/im as a qoutient module over algebra g0"
SuperLie`Cohom`chBookQ::usage="chBookQ[v] stores the cocycle that represents the cohomology v built by chQuot[...]
  and returns this cocycle converted to output format. chBookQ[v1,v2,...] stores multiple cosycles with same weight."

SuperLie`Cohom`ch$M::usage="The module of differential forms"
SuperLie`Cohom`ch$Wt::usage="The name of the weight function relative to Cartan subalgebra of g0. Default is Weight."
SuperLie`Cohom`ch$ex::usage="The g0-module of exact forms"


SuperLie`Cohom`chExMod::usage=
 "chExMod[s,r] builds the g0-module of exact r-form of grade s"

SuperLie`Cohom`chMod::usage=
 "chMod[name,gen] builds the g0-module generated by form (or list of forms) gen."

SuperLie`Cohom`chDim::usage="chDim[m,...] calculetes the dimension of the [sum of] g0-module[s] of cohomoligies"

SuperLie`Cohom`chInMod::usage="chInMod[m,V] checks if vector V is inside m (modulo exact forms)"

SuperLie`Cohom`chInSol::usage="chInSol[m,V] solves condition V in m (modulo exact forms)"

SuperLie`Cohom`chExSol::usage="chInSol[V] solves condition V==0 (modulo exact forms)"

SuperLie`Cohom`chRate::usage=
 "chRate[v] returns the rating table for coefficients in general sum (for selecting
 in mixed cohomologies)"

SuperLie`Cohom`chSplit::usage = "The user-defined function used to split basis to homogenous parts"
SuperLie`Cohom`chBasis::usage =
    "The user-defined function chBasis[r,s] should return the list of all r-forms of degree s"

SuperLie`Cohom`chPrint::usage = "chPrint[s,r] prints the results of calculations of (<=r)-cohomologies of grade s."

SuperLie`Cohom`ch$Print::usage = "Controls the amount of informatiom printed by chPrint. Default is 0.
 Set to -1 to disable all printing."


SuperLie`Cohom`ch$Out::usage = "The value of ch$Out is a function that is applied to cohomologies when printing.
 The default value is Identity."

SuperLie`Cohom`chNext::usage = "chNext[] shows the next calculated cohomology. If the cohomology is pure, the
 result is stored (using chBook[]) and returned. Otherwise the function returns
 the equations of exactness and the rates of coefficients are shown instread. To store the results
 in this case, the user should invoke chBook with appropriate arguments.
 chNext[degree] begins enumerating the cohomologies of the given degree."

SuperLie`Cohom`chBook::usage =
 "chBook[repl, ...] stores the calculated cohomology(-ies) after replacing the undeterminate
  scalar coefficients first using the given replacement rules and then the remaining ones with 0.
  Specify separate argument for each element of the basis of cohomologies. chBook[] stores a
  cohomology for every undeterminate scalar coefficient."

SuperLie`Cohom`ch$book::usage =
  "The final results of calculations are stored as values of ch$book[degree, rank, selector].
   For persistent storage, supply own storage by binding ch$book to some symbol e.g., ch$book = MyBook"

SuperLie`Cohom`chPos::usage =
  "chPos[] returns the current position in the calculations as a sequence degree, rank, selector"

Begin["$`"] (***********************************************************)

ch$Print = 0;

ch$Out = Identity;

chSetAlg[alg_, dalg_, g0_:None, cf_:"Manual", opts___Rule] :=
  (ch$alg = alg;
    ch$g0 = g0;
    ch$d = dalg;
    ch$grades = Grade/@Basis[alg];
    ch$minGrade = -Max@@ch$grades;
    ch$maxGrade = -Min@@ch$grades;
    Clear[dbas];
    dbas[k_] := dbas[k] = DegreeBasis[k, Basis[ch$d], Wedge, If[SkewSymmetricQ[Wedge] || AntiSymmetricQ[Wedge], 0, 1]];
	If[g0===None,
      DLeft[alg -> dalg, opts],
	(*else*)
      DLeft[alg -> dalg, Algebra -> g0, opts];
      DLeft[alg -> dalg, Clear -> False, opts]
    ];
    Which[
      NumberQ[cf],  (* trivial coefficients *)
        BasisPattern[ch$M] ^= _wedge|_dalg|VTimes[];
	chBasis[0,d_] := If[d==0, {VTimes[]}, {}];
        chBasis[r_,d_] := If[r*ch$minGrade<=d<=r*ch$maxGrade, dlist[d, r], {}],
      SymbolQ[cf],
        BasisPattern[ch$M] ^= _Tp;
	chBasis[0,d_]:=Basis[cf,d];
        chBasis[r_,d_]:=
          Flatten[Table[
            Outer[Tp, Basis[cf,d-i], dlist[i, r]], {i, r*ch$minGrade, r*ch$maxGrade}]],
      ListQ[cf],
        BasisPattern[ch$M] ^= _Tp;
	chBasis[0,d_]:=Select[cf,Grade[#]==d&];
        chBasis[r_,d_]:=
          Flatten[Table[
            Outer[Tp, Select[cf,Grade[#]==d-i&], dlist[i, r]], {i, r*ch$minGrade, r*ch$maxGrade}]],
      True,
        BasisPattern[ch$M] ^= _Tp;
	chBasis[0,d_]:=chBasis[d];
        chBasis[r_,d_]:=
          Flatten[Table[
            Outer[Tp, chBasis[d-i], dlist[i, r]], {i, r*ch$minGrade, r*ch$maxGrade}]]];
    )

chScalars[b_, c_] := (ch$b = b; ch$c = c; Scalar[b, c];)


chHVect[f_] := GeneralZero[ch$raise, f, ch$c]
chLVect[f_] := GeneralZero[ch$lower, f, ch$c]

ch$raise = ch$lower = {}

chGenDim[f_] := Length[MatchList[f, _ch$c | _ch$b]]

(******* Image and kernel of Der ******)

NDer[f_] := VNormal[Der[f]]
NDer0[f__] := VNormal[Der0[f]]

chCoHom[deg_, r_] :=
 With[{r1=Abs[r], fn=If[r>=0,chImKer,chKer]},
  Module[{v},
	v = SplitList[ch$basis[r1, deg], _, ch$Split];
	v = ApplySplit[chHVect, v];
	ch$res[deg, r1] = v = ApplySplit[fn[#, r1] &, v];
	DPrint[1,"(", deg, ",", r1, "): ", MapSplit[chGenDim, v]]]]

ch$res[__]:={}

chImKer[v_, r_] :=
  With[{dv = If[r == 0, NDer0[v, ch$alg], NDer[v]], b = ch$b, c = ch$c},
    DPrint[2, v -> dv];
    {GeneralReduce[VNormal[GeneralSolve[dv == 0, v, c]], c],
     VNormal[GeneralReduce[dv /. c -> b, b]]}
 ]

chKer[v_, r_] :=
  With[{dv = If[r == 0, NDer0[v, ch$alg], NDer[v]], b = ch$b, c = ch$c},
    DPrint[2, v];
    {GeneralReduce[VNormal[GeneralSolve[dv == 0, v, c]], c]}
 ]


(*
  Solves equations of exactness on coefficients of general
  closed r-form of grade deg and weight wt
*)
chEqu[deg_, r_, wt_] :=
  With[{ker = (wt /. ch$res[deg, r])[[1]], 
        im = (wt /. ch$res[deg, r - 1])[[2]]},
    SVSolve[ker == im, Array[ch$c, chGenDim[ker]], Array[ch$b, chGenDim[im]]]]


SVSolve[True, ___] := {{}}

P[Tp] ^= 0;
P[VTimes] ^= 0;
P[Wedge] ^= 0;

Off[Solve::svars]


chRes[deg_,r_Integer] :=chRes[deg,{0,r}];
chRes[deg_,{rmin_,rmax_}]:=
  Module[{wt, i, rt, tbr},
    rt = Table[MapSplit[chGenDim, ch$res[deg, r]], {r,rmin,rmax}];
    wt = Union @@ Map[First, rt, {2}];
    (*Print[wt];*)
    ch$tab[deg] = tbr = Prepend[Table[PartSplit[rt[[i]], #, ""], {i,rmax-rmin+1}],#]& /@ wt;
    If [ch$Print>0, Print[MatrixForm[tbr,TableDepth->2]]];
    If[ch$Print>=0 && Length[tbr]>0, Print["Total: ",Rest[Plus@@tbr/.""->0]]];]


chCalc[deg_,r_Integer] :=chCalc[deg,{0,r}];
chCalc[deg_,{rmin_,rmax_}]:=
  If[rmax>=0,
     Do[chCoHom[deg,i],{i,rmin,rmax}];
     ch$rng[deg] = {rmin,rmax};
     ch$pos = {deg, -1, 1};
     chRes[deg,{rmin,rmax}],
  (*else*)
     Do[chCoHom[deg,i],{i,rmin,-rmax-1}];
     chCoHom[deg,rmax];
     ch$rng[deg] = {rmin,-rmax};
     ch$pos = {deg, -1, 1};
     chRes[deg,{rmin,-rmax}]]

chCalcMore[r_:Auto] :=
  Module[{deg,rmin,rmax,rmaxnew},
    deg = ch$pos[[1]];
    {rmin,rmax} = ch$rng[deg];
    Which[
      r===Auto, rmaxnew=rmax+1,
      r>rmax,   rmaxnew=r,
      r<-rmax,  rmaxnew=r,
      _,        Return[chRes[deg,{rmin,rmax}]]];
    If [rmaxnew>=0,
      Do[chCoHom[deg,i],{i,rmax+1,rmaxnew}];
      ch$rng[deg] = {rmin,rmaxnew};
      chRes[deg,{rmin,rmaxnew}],
    (*else*)
      Do[chCoHom[deg,i],{i,rmax+1,-rmaxnew-1}];
      chCoHom[deg,rmaxnew];
      ch$rng[deg] = {rmin,-rmaxnew};
      chRes[deg,{rmin,-rmaxnew}]]]


(* Enumeration of cohomologies *)

chNext[degree_:Auto] :=
 Module[{i, r, comp, dk, di, d, i0, j0, deg, j1, jj},
    If[NumberQ[degree], ch$pos = {degree, -1, 1}];
    {deg, j0, i0} = ch$pos;
    j1 = ch$rng[deg][[1]];  (* min calculated arity of cohomologies in this degree *)
    For[i = i0, i <= Length[ch$tab[deg]], i++; j0 = -1,
      comp = ch$tab[deg][[i]];
      For[j = j0 + 1, j < Length[comp] - 1, j++,
        jj = j + j1;
        dk = If[ListQ[comp[[j + 2]]], comp[[j + 2, 1]], 0]; (* kernel dimension *)
        di = If[j > 0 && ListQ[comp[[j + 1]]], comp[[j + 1, 2]], 0]; (* image dimension *)
        d = dk - di;  (* dimension of cohomology *)
        If[d > 0,
          ch$pos = {deg, j, i};  (* current position *)
          ch$sel = comp[[1]];    (* current selector *)
          ch$im = If[j > 0 && ListQ[comp[[j + 1]]],  (* current image *)
                   (ch$sel /. ch$res[deg, jj - 1])[[2]], 0];
          ch$ker = If[ListQ[comp[[j + 2]]],  (* current kernel *)
                    (ch$sel /. ch$res[deg,jj])[[1]], 0];
          Return[ch$sel -> If[di==0,chBook[], {chEqu[deg, jj, ch$sel], chRate[ch$ker]}]]]]];
    "No more cohomologies"]

(* Store and print the results of calculations *)
chBook[] :=
  With[{c=MatchList[ch$ker,_ch$c]},
   If[c==={}, 
     ch$book[ch$pos[[1]], ch$pos[[2]], ch$sel] = ch$ker;
     ch$Out[ch$ker],
   (*else*)
   chBook @@ (#->1& /@ c)]]
 
chBook[rep_] :=
  With[{r = ch$ker /. rep /. _ch$c -> 0}, ch$book[ch$pos[[1]], ch$pos[[2]], ch$sel] = r; ch$Out[r]]

chBook[rep__] :=
  (ch$book[ch$pos[[1]], ch$pos[[2]], ch$sel] =
     (With[{r = ch$ker /. # /. _ch$c -> 0}, Print[ch$Out[r]]; r]& /@ {rep});Length[{rep}])

chRes[]:=ch$book[ch$pos[[1]], ch$pos[[2]], ch$sel]

chPos[]:=Sequence[ch$pos[[1]], ch$pos[[2]], ch$sel]


ch$Wt = Weight
ch$basis = chBasis
ch$Split = chSplit
ch$gen = All

Vector[ch$M];
TheAlgebra[ch$M] ^= ch$g0;
BasisPattern[ch$M] ^= _Tp;
Bracket[ch$M] ^:= Bracket[ch$g0];

chQuot[q_, d_, r_] :=
  Module[{im, ker},
    ker = Flatten[GeneralBasis[#[[2, 1]], ch$c] & /@ ch$res[d, r]];
    im = Flatten[GeneralBasis[#[[2, 2]], ch$b] & /@ ch$res[d, r - 1]];
    QuotientModule[q, ch$M, im, Module -> ker,Split\[Rule]ch$Split]]

chBookQ[v_, vv___] :=
 Module[{d = Grade[v], w = Weight[v], q = TheModule[v], rep, r, ker},
  rep = MappingRule[ch$M, q];
  r = rep[[1, 1]];
  If[Head[r] === Tp, r = r[[2]]];
  r = Length[r];
  ker = (w /. ch$res[d, r])[[1]];
  ch$book[d, r, w] =
   If[Length[{vv}] > 0,
    (GeneralSolve[# == ker /. rep, ker, $`ch$c] /. _$`ch$c ->
         0) & /@ {v, vv},
    (*else*)
    GeneralSolve[v == ker /. rep, ker, $`ch$c] /. _$`ch$c -> 0];
  Thread[ch$Out[ch$book[d, r, w]]]]

chExMod[deg_, d_, gen_:ch$gen] := 
  With[{imgen = Flatten[(GeneralBasis[#1[[2, 2]], ch$b] &) /@ ch$res[deg, d - 1]],
        opt=If[gen===All,Unevaluated[],Act->gen]}, 
    SubModule[ch$ex, ch$M, imgen, Split->ch$Wt, opt]; PDim[ch$ex]]

chMod[name_,gen_List,g0gen_:ch$gen] :=
  With[{opt=If[g0gen===All,Unevaluated[],Act->g0gen]}, 
  SubModule[name, ch$M, gen, Split->ch$Wt, opt]; chDim[name]]

chMod[name_,gen_,opt___] := chMod[name,{gen},opt]


chDim::usage="chDim[m,...] calculetes the dimension of the [sum of] g0-module[s] of cohomoligies"
(* this version is too slow for big modules *)
chDim[mm__] := 
  Module[{b = Join @@ Image /@ {mm, ch$ex}, c},
    b = P /@ GeneralBasis[GeneralReduce[GeneralSum[c, b], c], c]; 
    c = Plus @@ b; {Length[b] - c, c} - PDim[ch$ex]]


chDim[mm__] := Module[{b = Join @@ Image /@ {mm, ch$ex}, c, d, p, pp = {0, 0}},
    b = SplitList[b, _, ch$Wt];
    DPrint[2, {"Split:", Length[b]}];
    ForSplit[{b, w -> v},
      DPrint[3, {"w:", w, "Dim:", Length[v]}];
      p = P /@ GeneralBasis[GeneralReduce[GeneralSum[c, v], c], c]; 
      d = Plus @@ p; pp += {Length[p] - d, d}; DPrint[3, {"Dim:", pp}]];
    pp - PDim[ch$ex]]

(*
DimVv[m_, v_] := 
  Module[{b = Join[Image[m], Image[imd], GeneralBasis[v, c]], c}, 
    b = P /@ GeneralBasis[GeneralReduce[GeneralSum[c, b], c], c]; 
    c = Plus @@ b; {Length[b] - c, c} - PDim[imd]]
*)

chInMod::usage="chInMod[m,V] checks if V is inside m (modulo exact forms)"

chInMod[m_, v_] := 
  Module[{w = ch$Wt[v], 
      b = Join[Select[Image[m], ch$Wt[#]==w&], Select[Image[ch$ex], ch$Wt[#]==w&]],
      c, dm},
    b = P /@ GeneralBasis[GeneralReduce[GeneralSum[c, b], c], c]; 
    c = Plus @@ b;
    dm = {Length[b] - c, c};
    b = Join[b, {v}];
    b = P /@ GeneralBasis[GeneralReduce[GeneralSum[c, b], c], c]; 
    c = Plus @@ b;
    {Length[b] - c, c} - dm
    ]

chInSol[m_, v_] := 
  With[{w = ch$Wt[v],k=chGenDim[v]}, 
    Module[{bas = Join[Select[Image[m], ch$Wt[#]==w&], Select[Image[ch$ex], ch$Wt[#]==w&]], b},
      SVSolve[GeneralSum[b, bas] == v, Array[ch$c, k], Array[b, Length[bas]]]]]

chInSol[m_, v_List] := chInSol[m, GeneralSum[ch$c,v]]

chExSol[v_] := 
  With[{w = ch$Wt[v],k=chGenDim[v]}, 
    Module[{bas = Select[Image[ch$ex], ch$Wt[#]==w&], b},
      SVSolve[GeneralSum[b, bas] == v, Array[ch$c, k], Array[b, Length[bas]]]]]

chRate[v_] := 
  Table[Length[Select[List @@ v, !FreeQ[#, ch$c[i]] &]], {i, chGenDim[v]}]

chBasis[0,d_]:=chBasis[d];

chBasis[r_,d_]:=
    Flatten[Table[
        Outer[Tp, chBasis[d-i], dlist[i, r]], {i, r*ch$minGrade, r*ch$maxGrade}]];

dlist[d_, 1] := Select[Basis[ch$d], Grade[#] == d &]
dlist[d_, k_] := Select[dbas[k], Grade[#] == d &]

chWt[v_] := Weight[v]

chSplit[v_] := "";

End[]
EndPackage[]
